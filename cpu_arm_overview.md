#第一章  概述
##七种运行模式
1. 用户模式
2. 快速中断模式fiq             用于高速数据传输和通道处理
3. 外部中断模式irq             相应外部中断处理
4. 特权模式sve                     操作系统使用的保护模式，使用场景未知。
5. 数据访问中止模式abt      用于虚拟存储及存储保护
6. 未定义指令中断模式und  通过软件仿真硬件的协处理器
7. 系统模式 sys                    运行特权级的操作系统任务
可以看出，ARM处理器的模式比MIPS更加多样化，可以适应更多的应用场景。

模式切换：从用户模式不能直接切换到系统模式，需要由用户程序产生异常处理，比如缺页，系统调用中断等进入异常模式。

##寄存器
寄存器：每种异常模式都有一组独立的寄存器，可保证用户模式下寄存器不被破坏。（但部分寄存器可能是共用的）

通共有37个寄存器，包括31个通用寄存器和6个状态寄存器。用寄存器可分为三类：
1. 未备份寄存器R0~R7
2. 备份寄存器
3. 程序计数器PC

快速中断模式，有R8~R14共8个完全独立的寄存器，这样可以保证在fiq模式下可以不用做太多的现场保护，从而实现快进快出。

* R13，栈指针。user mode和sys mode共享R13，其他5种异常模式独享R13栈指针，保证不破坏user mode和sys mode的运行现场。
* R14，RA指针，连接寄存器。和R13类似，user mode和sys mode共享，其他5种异常模式独享R14 ra指针。
* R15，PC指针。当前执行的指令。比如向该寄存器写一个地址，程序会跳到该地址执行。
* CPSR，状态寄存器。7种模式共享。包含条件标志位、中断禁止位、处理器模式位、控制位、状态位等。
* SPSR，备份程序状态寄存器。5种异常模式独有。用于备份CPSR并在异常返回时恢复。
* fp指向该帧的第一个字，一般为保存的参数寄存器，
* 而sp指向栈顶。

##CPSR，状态及控制寄存器
条件标志位：Negative、Zero、Carry、oVerflow。表示算数运算中的一些状态位。在MIPS中进位丢失。
* Q标志位：DSP使用。
* 控制位：中断禁止位（I 禁止外部中断、F禁止FIQ）
* T控制位：控制指令的格式，如是ARM还是Thumb指令。
* M控制位：控制当前是什么模式。

##异常中断
ARM的控制流程包括：正常执行，条件或无条件跳转，异常中断。正常执行一条ARM指令，PC指针加4个字节，执行一条Thumb指令，PC指针加2个字节。Thumb指令更精简，也以为着需要更多存储。跳转，包括条件判断、程序返回。包括B跳转、BL跳转并准备返回地址、BX跳转并准备状态、BLX综合BL和BX。异常中断处理，需要保存和恢复现场。

##异常中断的分类及优先级（Linux是否支持中断优先级？）
* 复位，外部掉电引脚产生，优先级最高
* 未定义指令异常，指令未定义时产生，可以仿真浮点向量运算， ARM处理器和协处理器均可产生。
* 软件中断，用户模式调用特权模式指令。 预计将用于系统调用。
* 指令预取中止，指令地址不存在（text段被破坏？）或指令地址不允许访问（user访问内核地址空间指令？）。
* 数据访问中止，类似指令预取中止，地址不存在或地址不允许访问。
* 外部中断请求，响应外部器件的请求
* 快速中断请求，响应外部器件快速中断请求。预计，做的事情比较少，但是 数据量比较大 。快进快出。

为防止中断嵌套，通过CPSR寄存器，当进入IRQ模式时，禁用IRQ，进入FIQ模式时，禁用FIQ。

响应异常时，需要保存处理器的状态，并将返回地址存放到lr_mode寄存器，如前所述，为R14，且每个模式独有。预计，不同异常模式可以嵌套。
注意，从中断处理程序返回时，PC指针应该指向中断发生指令的下一条指令。

##存储系统
指令访问不对齐，结果未知，也有可能被忽略直接传到存储系统。存储系统不一定支持未对齐的内存的访问。也即结果仍然未知。
数据访问不对齐，结果未可知。有可能产生异常，或被处理器丢掉，或被处理器忽略并传递给存储系统。由不同的指令确定。
ARM支持若干条指令预取，以及支持自修改代码。但不同处理器的实现方式可能有所不同。因此需要具体处理器具体分析。

#第2章 寻址方式
##ARM指令格式
<opcode>{<cond>}{S}<Rd>,<Rn><shifter_operand>
31-----28--------24-----21-----19--16-15-12--11---------------0
|   cond  |  001  |  opcode  |  S  |   Rn   |   Rd   |  shifter_operand  |
-----4------3--------4--------1-----4-------4-----12---------------

一条ARM指令共32个bit。指令执行的流程, 因为从ARMv5开始，部分指令条件执行。
1. 读取指令
2. 根据指令格式，判断是否需要做条件判断。若是，转步骤3，否，转步骤4。
3. 读取条件编码检查CPSR标志位。若是，转步骤4执行指令，否，当前指令被当作NOP并转步骤5。
4. 执行指令
5. 检查是否有中断请求待处理。若是，当前流程被打断。
6. 读入下一条指令。
注意步骤5，每条指令执行完毕都需要检查中断。

##数据处理指令的寻址（Move、Add等）
寻址关系着指令能够看到内存的范围。比如第二个操作数宽度为12，那是否意味着只能寻址4K？再考虑字节对齐，也只能寻址16K的内存？这是不合理的。因此，在学习指令集之前，首先要考虑，从CPU的角度，如何定位内存，也即寻址。

在MIPS中，用两个指令来加载立即数的高位和低位。在ARM中，通过循环右移可实现对2^38范围地址的直接寻址，但后果是很多地址无法直接寻址（需要使用多条指令配合完成）。interesting。立即数的编码由编译器完成，译码由处理器完成。

**shifter_operand的三种方式**  
1. 立即数方式
	12位立即数被拆为两部分：<immed_8><rotate_imm>。<inmmediate>=<immed_8>循环右移(2*rotate_imm)。编码时，取rotate_imm最小的一个。
	0xff00，则immed_8=0xff, rotate_imm=C，即0xFFC
	0x104, immed=0x41, rotate_imm=F，即0x41F
	判断一个数是否为立即数的方法，循环右移x位得到immed_8，rotate_imm=(32-x)/2
2. 寄存器方式
	操作数即为寄存器的数值。由于寄存器为32位宽，因此寻址范围为4G。但为某一个寄存器赋值，可能需要两条指令。 
3. 寄存器移位方式
	包括算数右移ASR、逻辑左移LSL、逻辑右移LSR、循环右移ROR、扩展的循环右移RRX等。12位shifter_operand中，寄存器只占4个bit位，移位方式占3个bit位，移位宽度可以占5位即32。 可以和方式1配合使用。
	逻辑右移(SHR)是将各位依次右移指定位数，然后在左侧补0，算术右移(SAR)是将各位依次右移指定位数，然后在左侧用原符号位补齐。
	数据处理的寻址指令分为11种，分别是
	\#<immediate>    只使用立即数
	<Rm>                 只使用寄存器
	<Rm>  <Mode> <shift>  其中<Mode>={LSR/LSL/ASR/ROR }，<shift>={#shift_imm, Rs}。共8种。
	<Rm>, RRX     shift_operand = (C flag << 31) | (Rm > 1),  shifter_carry_out = Rm & 0x1
	当<shift> 为 shift_imm时，宽度为5bit，为Rs时，宽度为4bit。
	所有移位，都需要注意，当shift_imm=0时，循环器的进位值为CPSR的C条件标志位，当shift_imm不为0时，进位值为操作数shifter_operand的最高位 bit[32 - shift_imm] 。 

##数据存取指令的寻址（Load、Store）
Load/Store指令，和外存交互。指令的寻址包括两个部分：基地址寄存器+偏移量。其中偏移量可以用立即数、寄存器、立即数+寄存器三种方式。根据寻址是否更新基地址寄存器，又有三种方式：不更新、先更新后用，先用后更新。类似于i+1, i++, ++i。这三种形式的指令格式。 那是否意味着，对于ARM来说，i++是原子操作？

* [<Rn>, #+/-<offset_12>]
	偏移量为立即数，适用于偏移量编译时已知的情况，如结构体成员，参数和栈中数据的访问。
	标志位U，表示加或减偏移量。标志位B为1表示立即数无符号。标志位L为1表示Load否则为Store。
* [<Rn>, +/-<Rm>]
	偏移量为寄存器，适用于偏移量编译时未知，运行时计算得到。比如对存取数组的成员。
* [<Rn>, +/-<Rm>,<shift>#<shift_imm>]
	偏移量为立即数+移位立即数，适用于大数组的快速存取。移位方式包括LSL、LSR、ASR、ROR、RRX五中。所谓大数组，比如访问一个内存块。
* [<Rn>, #+/-<offset_12>]！
* [<Rn>, +/-<Rm>]！
* [<Rn>, +/-<Rm>,<shift>#<shift_imm>]！
上述三条指令为事先存取，类似++i的操作
* [<Rn>], #+/-<offset_12>
* [<Rn>], +/-<Rm>
* [<Rn>], +/-<Rm>,<shift>#<shift_imm>
上述三条指令为事后存取，类似i++操作。

##杂类数据存取方式
当操作数为半字H、有符号半字SH 、有符号字节SB 、双字D时，有特殊类指令。语法格式为：
```
LDR|STR {<cond>} H|SH|SB|D <Rd>,<address_mode>
```
其中<Rd>包括立即数和寄存器两种，立即数宽度为8。  
<address_mode>包括不更新、先更新后用和先用后更新三种。  
使用宏指令方便记忆，如LDRSB。  

##批量Load/Store存取
实现在一组寄存器和一块连续的内存单元中传输数据。由于寄存器数量有限，可以想象每次传递的数据也不会太多。但是却能够线性比例提高数据存取速度。bit[0]表示R0。可以一次最多存取16个寄存器即64字节，但由于寄存器寄存器的限制，其实并没有那么多。
* 有四种方式，事先递增IB、事先递减DB、事后递增IA、事后递减DA。用P和U两个标志位实现这四种方式。P为0，则先用后增。P为1，先增后用。U控制方向，为0向上，为1向下。
* W标志位，表示指令结束后，end_address的指写入基址寄存器。
* S标志位表示比较复杂。Supervisor。S为1。reg_list包含R15，则用于控制需要备份SPSR到CPSR。如果不包含R15，则用于控制特权模式下读取用户模式的物理寄存器。
* L表示存取类型。为0表示Load，为1表示Store。

##总结：
通过第二章，已经可以发现ARM和MIPS处理器的区别。ARM的寄存器少，但是更加的丰富，支持更多的模式，可以更灵活地适应场景。由于寄存器较少，因此可能导致程序体积变大，读写内存的指令将会有所增加。MIPS的指令虽然较多，但是觉得利用得并不是特别充分，很多小型的计算用不了那么多的寄存器。可能因为这个原因，ARM主攻嵌入式，而MIPS则重点服务器市场。或许可以理解为，MIPS重计算，ARM重应用。

#第3章 指令集
* 跳转指令，适用场景：函数调用， 模式切换， 进程切换，
* 数据处理指令，适用场景：算数计算，结构体读取，指针偏移
* 程序状态传输指令，适用场景：获取和设置处理器的各种状态，如溢出，进位，模式，中断屏蔽等
* Load/Store指令，适用场景：和外部存储器打交道
* 异常中断指令，适用场景：模式切换
* 协处理器指令：如MMU协处理器共有16个寄存器，需要指令在协处理器和ARM处理器之间传递数据。

##跳转指令：
1. 跳转指令，按照编码格式，signed_immed_24为可跳转的范围，即2^24 * 4，即当前地址前后32M。
2. 先构造跳转地址，再将该地址写到PC寄存器中，可以实现对4G地址空间的跳转。

对于跳转指令，  
B指令，只跳转不保存PC到RA中。RA已经被提前填充了。比如在进程切换的时候，RA是设计好后填充的。  
BL指令，跳转并保存返回地址到RA。比如子程序调用时，返回的地址可以自动确定的。  
BX指令，带状态切换不带返回的指令。 比如从子程序调用中返回。所谓状态切换，是指可以切换到ARM指令或thumb指令。  
BLX指令，带状态切换也带返回的指令。目标地址可以为立即数，也可以为寄存器。目标寄存器为ARM或Thumb，由CPSR的T位决定。  
子程序的调用和返回，也可以使用PUSH{<registers>, R14}, POP{<registers>, PC}来完成。cool。一条指令完成压栈和出栈。  

##数据处理指令：
分为三类：
1. 数据传输指令：MOV、MVN、
2. 算数逻辑运算：
3. 比较指令：不保存结果，只更新CPSR的条件标志位。CMP、CMN

##MOV指令
用于赋值和子程序或中断程序跳转。

如果目标寄存器是R15，也即程序跳转，则使用SPSR更新CPSR。也就是说，如果 S标志位被设置，那么当更新程序计数器寄存器R15的同时，还需要将状态寄存器CPSR还原为SPSR的值。（示例： MOVE PC LR，从某些异常中断返回）

如果目标寄存器是其他寄存器，当 S标志位被设置时，则根据传送的数值设置CPSR寄存器。其中N和Z取决于数组， C取决于移位器的进位值。

在正常指令的后面，加上S，比如MOVS、ADDS，表示带有S标志位。其他指令类似。 

##MVN指令
和MOV指令类似，将数据的反码传送到目标寄存器。

用于产生负数、生成位掩码（比如~0xFF）、求数的反码。在内存操作时，经常需要求掩码。

##ADD指令
```
Add {<cond>} {S} {Rd}, {Rn} , <shifter_operand>
```
shifter_operand宽度为12个bit，可以为立即数，或寄存器，或寄存器移位，或代码段偏移。有类似的S标志位，用于控制如何更新CPSR。
 
##ADC 带位加法指令
和ADD指令相比，首先加法运算时需要带上当前的CPSR的C flag。然后需要使用计算结果更新CPSR的C Flag和V flag。使用该指令，可以实现超过32位的大数相加。
```
ADDS R4,R0,R2      #C flag = CarryFrom(R0+R2)
ADCS R5,R1,R3      #R5=R1+R3+C flag, C flag =  CarryFrom(R1+R3+Cflag)
```

##SUB减法指令
和加法指令类似,需要注意，如果S标志位被设置，那么C flag = Not CarryFrom(Rn - Shifter_Operand),即如果发生借位，则C flag设置为0，否则为1。这与ADDS相反。

##SBC 带位减法指令
```
Rd = Rn - shifter_operand - NOT(C flag)
SUBS R4, R0,R2   #C flag = Not BorrowFrom(R0 - R2)
SBC R5,R1,R3  #R5 = R1 - R3 - Not (C flag)  注意，如果发生之前发生过借位，那么这里的C flag为0，再次取反，则为1。
```

##RSB 逆向减法指令
减法操作和SUB类似，但是，操作顺序却是反的。Rd = shifter_operand - Rn  支持S标志位

##RSC 带位逆向减法指令
和SBC类似，但减数和被减数与SBC相反。即Rd = shifter_operand - Rn - Not(C flag), 支持S标志位

AND逻辑与操作指令    Rd = Rn AND shifter_operand    支持根据S标志位更新CPSR

ORR逻辑或指令  Rd= Rn OR shifter_operand  支持根据S标志位更新CPSR

EOR 逻辑异或指令  Rd = Rn EOR shifter_operand，逻辑异或操作，根据shifter_operand，对Rn做异或操作。异或，可用于对标志位求反。

BIC位清除指令  将shifter_operand的反码和Rn的值做与运算，从而实现对部分位清除的动作。


##CMP指令
类似与SUBS指令，但是CMP不将结果保存到Rd寄存器。计算Rn - shifter_operand的值，并更新结果到CPSR。比如CMP相等，则Z flag为1，否则为0。CMP大于，则C flag为0，否则为1。  
CMN 基于相反数的比较指令  
根据加法的结果，更新CPSR。使用场景未知。

##TST指令
类似于逻辑与操作，但是不更新目标寄存器。

##TEQ 相等测试指令
类似于逻辑异或操作，但是不更新目标寄存器。用于判断两个数值是否完全相等。

##乘法指令
MUL指令  两个32位寄存器的操作数相乘，将结果的低32位保存到目标寄存器。符号位也丢失。  
MLA指令  Rd = (Rm * Rs + Rn)[31:0]  
SMULL SMLAL UMULL UMALL 指令助记符的第一个S和U表示是否带符号，最后面的L表示将结果保存到两个寄存器  

##CLZ指令，
计算操作数最高端0的个数，用于1）使最高位为1时需要左移的位数，2）确定优先级掩码中的最高优先级

##状态寄存器访问指令
MRS  状态寄存器到通用寄存器的传送指令，状态寄存器包括SPSR和CPSR  
MSR  通用寄存器到状态寄存器到传送指令 ，状态寄存器包括SPSR和CPSR  
主要用于上下文切换时保存和恢复状态寄存器，以及某些情况下修改状态寄存器。
对于MSR寄存器，为提高效率，将32bit的状态寄存器分为4个位域，分别用f、s、x、c表示。  
比如MSR CPSR_c, R0，表示将R0的低8bit写入到状态寄存器。

#3LDR指令
按字读取内存，需要注意的是如果地址不是字对齐，怎么办。http://www.groad.net/bbs/thread-1371-1-1.html

原本设想的读取 0xbffffe99 会连续 0xbffffe99-0xbffffe9a-0xbffffe9b-0xbffffe9c 这 4 个内存单元内容是错误的。实际上仍然读取的是 0xbffffe98 ~ 0xbffffe9b 这 4 个连续内存单元的内容。由于你读取的地址不对齐，编译器会认为你的兴趣就是要读取那个不对齐的内存单元( 0xbffffe99 对应上的 0x66 ) 的内容，所以循环右移，将其送往低 8 位。 

##LDRB 字节数据读取指令
```
LDR{cond}B <Rd>, <addressing_mode>
```
从内存中读取一个字节放入到Rd中，由于Rd本身可以容纳4个字节，因此需要将高24位清零。这里的{cond}可以为S，是否带有符号位。如果带符号位，那么该指令就是LDRSB，不是将高24位清零，而是将高24位用读取的字节的符号位进行扩展。

##LDRBT 用户模式下的字节数据读取指令
在特权模式下，内存系统将该操作当作用户模式的内存访问操作。注意，这里提到内存系统，也即处理器只是发出指令，具体的读取依赖于内存系统的判断，比如判断当前模式是否可以读取指定内存。

LDRT  用户模式下的字读取指令，和LDRBT类似，但读取的宽度为4个字节。

LDRH  半字数据读取指令

LDRSB  符号位扩展的LDRB

LDRSH  符号位扩展的LDRH

STR   字数据写入指令

STRB  字节数据写入指令，将源寄存器的低8位写到目标内存位置。

STRH  半字数据写入指令。 要求目的地址半字对齐

STRT  用户模式下的STR

STRBT  用户模式下的STRB

##批量内存访问指令
用于块数据的读取与写入，数据栈操作，比如出栈入栈，从子程序返回（出栈）

LDM 指令

LDM(1)  指令的低16位表示寄存器列表，当register_list[15]有设置时，将会修改到PC寄存器，从而发生跳转动作。根据待跳转地址的bit[0]区分跳转的是ARM指令，为1表示跳转的Thumb指令。编号低的寄存器对应内存中低地址内存单元。 如果指令中带有!，表示更新基地址寄存器。

LDM(2)  在 特权模式下，按照用户模式访问内存。由内存系统控制。注意区别特权模式与系统模式和用户模式。 异常中断程序在特权级处理器模式下执行，可用该指令按用户模式权限访问内存。该指令通常后面跟nop指令。

LDM(3)  读取内存到寄存器的同时，还赋值SPSR寄存器到CPSR寄存器中。

STM(1)  写寄存器到内存中。

##ARM条件码
* EQ : 等于 ， 如果一次比较之后设置了 Z 标志。  
* NE : 不等于， 如果一次比较之后清除了 Z 标志。  
* VS : 溢出设置， 如果在一次算术操作之后设置了 V 标志，计算的结果不适合放入一个 32bit 目标寄存器中。  
* VC : 溢出清除， 如果清除了 V 标志，与 VS 相反。  
* HI : 高于(无符号) ， 如果一次比较之后设置了 C 标志并清除了 Z 标志。  
* LS : 低于或同于(无符号) ， 如果一次比较操作之后清除了 C 标志或设置了 Z 标志。  
* PL : 正号， 如果一次算术操作之后清除了 N。出于定义‘正号’的目的，零是正数的原因是它不是负数...  
* MI : 负号， 如果一次算术操作之后设置了 N 标志。  
* CS : 进位设置， 如果一次算术操作或移位操作之后设置了 C 标志，操作的结果不能表示为 32bit。你可以把 C 标志当作结果的第 33 位。 
* CC : 进位清除， 与 CS 相反。  
* GE : 大于或等于(有符号) ， 如果一次比较之后...  设置了 N 标志并设置了 V 标志  或者...  清除了 N 标志并清除了 V 标志。  
* GT : 大于(有符号) ， 如果一次比较之后... ， 设置了 N 标志并设置了 V 标志， 或者... ， 清除了 N 标志并清除了 V 标志， 并且... ， 清除了 Z 标志。  
* LE : 小于或等于(有符号) ， 如果一次比较之后...  设置了 N 标志并清除了 V 标志  或者...  清除了 N 标志并设置了 V 标志  并且...  设置了 Z 标志。  
* LT : 小于(有符号) 如果一次比较之后...  设置了 N 标志并清除了 V 标志。  或者...  清除了 N 标志并设置了 V 标志。   　  
* AL : 总是 缺省条件，所以不用明显声明。  
* NV : 从不 不是特别有用，它表示应当永远不执行这个指令。相当于NOP。包含 NV 是为了完整性(与 AL 相对)，不推荐在代码中使用它。  
* S:   还有一个条件代码是S，它表示执行操作后，接着把SPSR的内容恢复到CPSR中。例如: 
	  ADD     R0, R0, R1
	  ADDS    R0, R0, R1
	  ADDEQS  R0, R0, R1

第一个例子是一个基本的加法(把 R1 的值增加到 R0)，它不影响状态寄存器。

第二个例子是同一个加法，只不过它导致更改状态寄存器。

最后一个例子是同一个加法，更改状态寄存器。不同在于它是一个有条件的指令。只有前一个操作的结果是 EQ (如果设置了 Z 标志)的时候它才执行。

第4章  ARM汇编

第5章  存储相关 MMU和cache

第6章 ATPCS 子程序调用

第7章 ARM程序与Thumb程序混合使用

第8章 C与汇编混合编程

第9章  异常与中断的处理

第10章  ARM编译器


第11章  ARM连接器


第12章  嵌入式应用程序

第14章 调试方法

pipeline








 


 

