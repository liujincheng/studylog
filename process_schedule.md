摘要：  
本节主要介绍进程调度，进程切换，抢占。

---

##需求：
Linux的进程可运行在内核态和用户态，具备优先级，可分为交互进程，批处理进程，实时进程。需要根据这些特性合理为进程分配时间片，并在进程切换时保存和恢复进程的上下文，从而使得进程切换在用户看来完全透明。

进程切换发生的时机：  
1. 使用同步的系统调用，进程从用户态进入到内核态，完成业务处理后返回。如果说涉及到IO操作，则可能发生等待，需要将当前进程加入到等待队列中，之后执行schedule函数调度其他进程执行。等待IO操作结束后，外部器件会发送中断，在相应的驱动函数中唤醒等待队列，从而让进程有机会继续执行。注意，这里是有机会，也即只是修改进程的状态为R，让其有机会被调度到。
2. 异步的系统调用。其实流程和同步系统调用是类似的。区别在于，异步的系统调用，在将当前的进程加入到等待队列后，还会继续往后执行并返回用户态，由用户态来监控时间是否完成。而驱动得到IO数据后，也不是马上唤醒进程，而是做好准备，等待用户态的系统调用来检查数据准备情况。
3. 异步中断发生，相应芯片外部的事件，比如有新的报文达到。
4. 时间片到期，类似于中断，有外部arch timer定时触发。
5. 同步异常，比如发生缺页异常，或bus 错误等。


##学习方法：
学习内核调度，弄清楚内核调度模块的关键接口的功能，以及这些接口如何服务于其他模块。对于调度算法，只要知道有何功能即可，不用弄得特别清楚。因为调度算法属于内部实现，对于其他模块来说，算法对其他模块是透明的。


##理论知识：
用户态的进程有各自的地址空间，所以相互之间是隔离的，互相不知道彼此，不会干扰到其他进程的运行。当切换到内核态的时候，所有进程共享一个地址空间，可以访问到彼此。当进程发生系统调用的时候，会切换到内核态，一般情况下，只有系统调用完成，进程重新回到用户态的时候，进程调度才能够切换到其他进程。

当外部器件有事件发生，如收到报文时触发中断、收到键盘响应时触发中断等，为快速响应硬件，必须尽快从用户态进程切换到内核态，且不会考虑发生的中断是否与当前的进程有关系，甚至当前进程都不会察觉到中断发生。在2.5的内核之前，当内核处于系统调用阶段时，不能响应中断。当前的内核已经有优化，中断具备最高的优先级。但换句话说，除非发生中断，一般当进程在内核态执行系统调用的时候，不应该被其他的进程抢占。

所有进程共享物理内存，逻辑地址独立。所以进程的用户态地址空间仍然不会被映射到物理内存地址空间。物理内存不够用，还是会申请不到内存。也就是说，正常情况下，进程切换，虽然会保存/恢复上下文，但是其内存空间是不会丢失的。


##进程生命周期的主要状态
运行、等待、休眠、终止、僵死。考虑中断状态，又包含可中断运行，不可中断运行等衍生状态。如下是在ps命令的手册中查询到的进程的状态说明。
* D    uninterruptible sleep (usually IO)
* R    running or runnable (on run queue)
* S    interruptible sleep (waiting for an event to complete)
* T    stopped, either by a job control signal or because it is being traced
* W    paging (not valid since the 2.6.xx kernel)
* X    dead (should never be seen)
* Z    defunct ("zombie") process, terminated but not reaped by its parent


##进程抢占
使用抢占式内核可以保证系统响应时间。最高优先级的任务一旦就绪，总能得到CPU的使用权。当一个运行着的任务使一个比它优先级高的任务进入了就绪态，当前任务的CPU使用权就会被剥夺，或者说被挂起了，那个高优先级的任务立刻得到了CPU的控制权。在kernel2.6之前，只有cpu运行在低优先级进程的用户态，高优先级进程才能抢占。这是不完整的。在2.6之后，无论处于用户态，还是内核态，都可以被抢占。

从代码的角度，所谓最高优先级的任务就绪，是指该进程的状态被设置为R，并被放入到runqueue。当schedule()开始调度时，能够有机会立刻调度到。为保证调度的效率，需要考虑schedule()函数的位置，比如当从系统调用返回到用户态之前，加入schedule()，可以保证新的高优先级进程能够比当前进程之前执行。由于当前进程仍在runqueue中，所以任然有机会被调度到。

**抢占式内核的优点**  
* 使用抢占式内核，最高优先级的任务什么时候可以执行，可以得到CPU的使用权是可知的。使用抢占式内核使得任务级响应时间得以最优化。
* 低延迟, 内核中耗时路径如果太多，将会导致延迟增加。使用抢占可以部分解决问题。另外一种，是在内核耗时代码中加入主动条件调度的代码，让每次内核执行完一段代码后，就开始检测能否被调度中。
```c
int __sched _cond_resched(void)
{
 if (need_resched() && !(preempt_count() & PREEMPT_ACTIVE)) {
  __cond_resched();
  return 1;
 }
 return 0;
}
static inline int need_resched(void) 
{  
    return unlikely(test_thread_flag(TIF_NEED_RESCHED)); 
}
```
不同的体系结构，对于该标志位有不同的理解，这个字段定义在arch下。通过set_tsk_need_resched和clear_tsk_need_resched设置任务的TIF_NEED_RESCHED标志位。主要在resched_task(struct task_struct *p)调用该字段。

**抢占式内核的缺点**    
* 不能直接使用不可重入型函数。调用不可重入函数时，要满足互斥条件，这点可以使用互斥型信号量来实现。如果调用不可重入型函数时，低优先级的任务CPU的使用权被高优先级任务剥夺，不可重入型函数中的数据有可能被破坏。


