##一个进程的生命周期，  
从fork开始，该函数为新的进程准备虚拟地址空间，也就是建立页目录，同时创建建立task struct管理数据结构，初始化栈。  
然后execve函数会为加载可执行文件，找到合适的binary loader执行加载流程。对于不同类型的可执行文件，加载器会有所区别，比如elf文件，Python脚本等。  
进程的装载过程使用页映射，也即初始只分配虚拟地址空间，只有在在发生缺页异常时，才会将实际的文件调入到内存中。  
如果在shell中敲回车执行一个命令，则会有sh来fork进程空间，然后使用execve来加载实际的可执行文件。system命令和此效果类似，只是system是由当前程序fork。  
对于静态链接的程序，会跳转到可执行文件的入口处执行，而对于动态链接的程序会跳转到动态链接器执行，区分的标准在于看程序的段中是否有intept段。一般来说，用户态程序都是动态链接的，静态链接用于测试或者演示较多。但在系统层面，比如在lk中，就是静态链接的可执行文件。不过lk不是elf格式的。  
  
  
##信号量和互斥量的区别，  
同一个信号量可以被一个线程获取，被另外一个线程释放，而同步则是谁申请谁释放。比方说，在生产者消费者模型中，生产者完成任务后释放信号量a，等待信号量b，此时消费者得知信号量a被释放，了即有数据待处理，则会开始处理数据。消费者处理完数据后，释放信号量a。生产者监控到信号量b被释放，继续开始生产的过程。  
互斥量，谁用谁释放，可以保证临界数据只有一个时间只有一个用户可以修改。  
kernel进化成读写锁的模型。  
  
##程序的指令和数据分开的原因  
更安全。指令和数据会被映射到内存的不同区域，指令可读可执行，数据可读可写。  
更高效。指令和数据会被CPU的data和instruction cache分开缓存，命中率更高。  
更经济。只读内存可以在多个程序之间共享。  
  
##静态链接的过程--合并相似段  
空间和地址分配。扫描目标文件，生成全局符号表（各种符号在可执行文件中新的位置），建立新的段表（各种段在可执行文件中新的偏移）。  
符号解析与重定位。解析全局变量，生成新的取指偏移值。解析函数地址，修正指令跳转方式。  
为可执行文件生成头部。比如入口地址。  
  
##共享链接库的意义  
从软件管理的角度，便于软件升级，可以用增量补丁的方式升级，而不用整体替换。  
从操作系统的角度，编译在不同的程序之间共享内存，节省内存空间。  
从处理器的角度，虽然进程切换时，进程上下文切换，但是由于共享库的存在，不用将所有cache全部换出，提高效率。  
  
##地址无关代码  
地址无关代码是动态链接库的核心技术。  
模块内部跳转。相当于当前指令的偏移。由于call指令支持该技术。  
模块内部数据访问。类似于模块内函数跳转，但没有相应指令，所以需要先获取当前pc地址。利用函数调用时，返回地址设置为当前指令的下一条指令，进而获取PC。  
模块间数据访问。ELF中有全局偏移表GOT段，进程加载动态链接库时，修正GOT  
