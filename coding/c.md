#tshell调用函数的实现方法
在MAP平台的tshell、BFC中，都可以指定函数名称，直接通过命令行调用函数。该功能的实现方法，很简单。在BFC中，命令为：
```
call func -a 0x8067b6c0
typedef uint32 (*Func0Args)(void);
Func0Args function = (Func0Args) pFuncAddressParameter->AsFlagParameter()->AsUnsignedInt();
returnValue = function();
```
其实现方式，就是直接将给定的地址转化为函数指针，调用。由于eCos所有线程共享地址空间，所以这种方式没有问题。MAP平台，单进程多线程，线程之间共用地址空间，给定符号名称后，查找符号表，定义到该函数的地址，再直接调用即可。

#sizeof
sizeof可以获取某个变量占用的内存大小。如果这个变量是指针，它只能获取这个变量本身占用的内存大小，而不能获取这个指针所指向的内存的大小，那怕那片内存是一个数组。

为什么？因为sizeof在编译期间就发生宏替换了。无法感知到运行期间的赋值。
```c
int main()
{
    int j = 0xaaaa ;
    long long ll = 0x123456789abcdef ;
    unsigned char* pc = (unsigned char*)&ll ;
    printf("ll=0x%x, j=0x%x/n", ll, j) ;
    printf("ll=%llx, j=%x/n", ll, j) ;
    printf("&ll=%p, &j=%p, pc=%p/n", &ll, &j, pc) ;
    printf("pc[0-8]=%02x %02x %02x %02x %02x %02x %02x %02x/n", pc[0], pc[1], pc[2], pc[3], pc[4], pc[5], pc[6], pc[7]);
    return 0 ;
}
```

#union 联合
可根据应用场景选择不同的字段。
当模块的代码升级到新的版本后，为了保持和旧的代码兼容，也可以使用union，同时支持多种字段。

#字节序：
ll=0x89abcdef, j=0x1234567    //这里出现打印错误。j为0xaaaa，结果打印显示为0x1234567。%x一次打印4个字节，但是ll长为8个字节，所以前面的%x打印了靠近&ll地址的4个字节，后面的%x打印了远离&ll地址的4个字节。这也从另外一个角度说明了，PC上字节序是小端的。
ll=123456789abcdef, j=aaaa  //llx就可以打印long long型了。
&ll=0xbff775b8, &j=0xbff775c4, pc=0xbff775b8  //可以看出，分配栈内存时，地址是向上增长的。

#三种循环的区别
有三种循环，合理利用，可以提高代码的可读性
* for               有条件判断，有变量递增。变量递增在执行语句完成之后。
* while           可以由条件判断。也可以讲变量递增和条件判断放在一起，但那样不容易阅读。使用该循环，执行语句可能一次也不会执行。
* do while     有条件判断，使用该方法，执行语句至少执行一次。
如果执行代码中包含多种递增条件，且互斥。那么for循环仅仅比while循环多了一个初始化的表达式。没有必要用for循环。

#字符串
字符串数据放在全局数据区中，且不可写。
```c
char *pa = "abc" ;
pa[0]='c' ;
```
编译没有错误，但是运行会报段错误。

#结构体赋值
```c
struct qstr{
 int a ;
 int array[5] ;
 int *p ;
};
void main()
{
 struct qstr q = {1, {3, 4, 5, 6, 7}, (int *)0x1122}, t;
 t = q ;
 printf("t.array[0]=%d, p=%p\n", t.array[0], t.p) ;
}
```
结构体可以直接赋值，和memcpy一样，是浅拷贝，赋值之后指针指向同一个地址。所以在对一个结构体中的指针free后，另外一个结构体中的这个指针也不再可用。

##链表
单链表遍历过程中，一般会有prev节点，表示前驱。由于需要curr->next的值会发生变化，所以还需要定义next节点，跟踪后继。如果curr的值有可能发生变化，那么就不能在for循环的递增表达式中使用curr。

需要检查，代码的返回值是否在所有的条件下都有。

#数组操作，
需要仔细考虑数组的尾标，避免越界。  

算数运算符+=，需要考虑该变量的初值是否恰当。特别是在while循环中使用+=，需要考虑是否每次循环都应该对变量初始化。

字符串长度，在使用malloc为字符串申请内存的时候，其长度应该是len+1，而不要直接对len的值做加1操作。和strlen保持一致。否则代码会变得混乱。
malloc申请内存，需要判断内存是否为空。


#预编译宏
1. 可以加入错误代码，快速判断预编译宏有没有生效。
2. 文件级预编译宏是否生效，与函数调用没有关系。

	```c
	void print1()
	{
	#ifdef TEST
	 printf("in macro\n") ;
	#endif
	}
	#define TEST 1        ////如果在此处定义宏，并不会生效。

	void main(){ print1() ; }
	```

3. 即使将#define宏定义放在函数内部，该宏将会对宏之后的所有代码都生效。而不会说只对某一个宏生效。
因此，如果希望宏只在某一个函数内生效，需要使用#undef取消宏定义。

#typeof关键字
获取表达式的类型typeof(*x) y
示例：
```c
  struct
  {int a ;
   char b ;
  } *x ;tshell     //x的结构体没有名称
  typeof(*x) y ;
  typeof(x) z ;
  printf("typeof(*x) = %d\n", sizeof(y)) ;   //8
  printf("typeof(x) =%d\n", sizeof(z)) ;     //4
```
#指针
##指针和数组的区别：
* 数组在初始化时分配内存，但指针所指向的内存则不会分配。
* 数组本身是一块内存的名称，它的地址无法改变。指针所指向的内存地址可以改变，也可以指向malloc分配的匿名内存。
* 在编译阶段，一个数组就是一个地址，但一个指针是一个地址的地址。
* 数组和指针，在声明中是严格匹配的，不能混合实用。
* 在多重数组时，对指针做算数操作，只能偏移变量本身占有的内存大小，比如int偏移4个字节，但是对数组做算数操作，地址偏移量与数组的规模和维数有关系。

##指针和数组的相同：
* 在表达式中，指针和数组可以混合使用。这是因为在表达式中，数组名其实会被转化为指向该数组第一个元素的指针。
* 在函数形参传递时，指针和数组可以混合使用。  
* 可以把数组下标作为指针的偏移量，也可以把对指针做算数运算作为数组的下标。比如p[i], a+1。

C语言中，凡不加类型说明的函数，一律自动按整型处理。

如果p不是NULL指针，那么free对p 连续操作两次就会导致程序运行错误。




