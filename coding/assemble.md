```
0x7ffd3720
   ----fun
0x7ffd3748
   ----main
0x7ffd3770
   ----

(gdb) x/512x 0x7ffd3700
0x7ffd3700: 0x0000000c 0x00000000
0x7ffd3708: 0x0000000d 0x00000000
0x7ffd3710: 0x0000000e 0x00000000
0x7ffd3718: 0x77257470 0x00400114
0x7ffd3720: 0x7725010c 0x00000000 (1)sp指针
0x7ffd3728: 0x00000000 0x004006f0
0x7ffd3730: 0x00418950 0x00000000 (1)16(sp)反汇编的_gp的值
0x7ffd3738: 0x0000aabb 0x00000000 (1)局部变量c，
0x7ffd3740: 0x7ffd3748 0x004007f0 (1)32(sp)，为第一个参数的地址，(2)36(sp) main函数中fun后的下一个指令，即ra。0x3720+0x24=0x3744
0x7ffd3748: 0x0000ccaa 0x004008f0 (1)40(sp)参数1，传值； (2)44(sp)参数2，传指针，指向rodata
0x7ffd3750: 0x00000000 0x00000000
0x7ffd3758: 0x00418950 0x7ffd3844 (1)该值和gp寄存器的值相等，也和反汇编出的_gp符号
0x7ffd3760: 0x004008f0 0x0040079c
0x7ffd3768: 0x7f8e75e0 0x771f1f90 (1)main的ra，在动态链接库中，但是查看maps没有相应地址
0x7ffd3770: 0x00000001 0x7ffd3844 (1)main参数argc，(2)main参数argv
0x7ffd3778: 0x7719a7e4 0x7719fdb4
```

```c
int fun(int a, char *pc)
{
  400730: 27bdffd8 addiu sp,sp,-40     #ljc 修改堆栈，为临时变量区划分40个字节，即0x28个字节
  400734: afbf0024 sw ra,36(sp)        #ljc sw, store word指令，从内存中加载数据。而move是两个寄存器的赋值，不涉及到内存操作。
  400738: afbe0020 sw s8,32(sp)    #将上一个栈的栈顶指针存在栈中，便于在程序执行结束后恢复栈顶。
  40073c: 03a0f021 move s8,sp      #将新的sp指针存入到s8，s8通常做为fp寄存器使用。
  400740: 3c1c0042 lui gp,0x42         #ljc $gp=0x420000,没有办法一条指令加载一条超过16位的立即数，需要使用两条指令加载。
  400744: 279c8950 addiu gp,gp,-30384  #ljc $gp=0x418950，该值即_gp符号的变量。因为0x418952的值需要分成两部分加载
  400748: afbc0010 sw gp,16(sp)        #ljc 将gp寄存器保存到栈中16(sp)，
  40074c: afc40028 sw a0,40(s8)        #ljc a0保存的是第一个参数，把它放到栈中。注意，fun栈的长度为40个字节。参数其实保存在ra函数的栈的顶部。
  400750: afc5002c sw a1,44(s8)        #ljc a1保存的是第二个参数。MIPS使用a0~a4传参，超过4个才使用内存。
 int c = 0xaabb ;
  400754: 3402aabb li v0,0xaabb        #ljc 将立即数0xaabb加载到v0的低16位
  400758: afc20018 sw v0,24(s8)        #ljc 将v0的值写到栈中。地址为24(s8)。由于栈较大，所以其实20(s8)是没有用得上的。16(sp)村的是gp
 printf("%s\n", pc) ;
=>40075c: 8fc4002c lw a0,44(s8)        #ljc 读取第二个参数，保存到a0寄存器中，作为参数传递给printf函数。
  400760: 8f828034 lw v0,-32716(gp)    #ljc $v0的值为0x400870，查反汇编文件，该地址为puts函数的地址
  400764: 0040c821 move t9,v0          #ljc 将v0赋值给t9
  400768: 0320f809 jalr t9             #ljc 跳转指令。需要设置当前指令地址加8，放入ra地址中。
  40076c: 00000000 nop
  400770: 8fdc0010 lw gp,16(s8)
 c++ ;
  400774: 8fc20018 lw v0,24(s8)     #执行一条自增语句，需要三条指令
  400778: 24420001 addiu v0,v0,1
  40077c: afc20018 sw v0,24(s8)
 return c ;
  400780: 8fc20018 lw v0,24(s8)     #如果使用优化编译，40077c和400780可以省略
}
  400784: 03c0e821 move sp,s8       #s8充当fp。不确定多层函数内有｛｝代码块时，是否会变化。
  400788: 8fbf0024 lw ra,36(sp)     #还原ra
  40078c: 8fbe0020 lw s8,32(sp)     #还原sp寄存器
  400790: 27bd0028 addiu sp,sp,40   #出堆栈，相当于pop指令
  400794: 03e00008 jr ra            #执行完毕，返回。cpu需要让它的cache失效。
  400798: 00000000 nop              #延迟执行槽。由于使用O0编译，所以这里使用nop作为延迟槽。
End of assembler dump.
(gdb) info reg
          zero at v0 v1 a0 a1 a2 a3
 R0 00000000 fffffff8 0000aabb 0000ccaa 0000ccaa 004008f0 7ffd384c 00000000
            t0 t1 t2 t3 t4 t5 t6 t7
 R8 81010100 2f2f2f2f 77250000 f0000000 00000001 7725233c 7ffd3400 004005f0
            s0 s1 s2 s3 s4 s5 s6 s7
 R16 7ffd3844 00000001 0040079c 7ffd3f0a 0040052c 771cba60 004560a0 007e641c
            t8 t9 k0 k1 gp sp s8 ra
 R24 00000010 0040079c 7ffd3421 00000000 00418950 7ffd3720 7ffd3720 004007f0
        status lo hi badvaddr cause pc
      00008d13 00037951 00000037 7723eaf4 00000024 0040075c
          fcsr fir restart
      00000000 00000000 00000000 

sw ra,36(sp)
*(sp + 36) = ra
li v1,0xccaa
v1 = 0xccaa
lui t u
t = u << 16
move s8,sp
s8 = sp
j
```

无条件跳转到绝对地址。高4位由pc指针给出，28位可以给出最大256M的代码大小。

jal和jalr
实现直接和间接的子程序调用。jr ra，从当前函数中返回。

下面给以详细说明：
$0:即$zero,该寄存器总是返回零，为0这个有用常数提供了一个简洁的编码形式。  
           move $t0,$t1  
       实际为  
           add $t0,$0,$t1  
       使用伪指令可以简化任务，汇编程序提供了比硬件更丰富的指令集。  
$1:即$at，该寄存器为汇编保留，由于I型指令的立即数字段只有16位，在加载大常数时，编译器或汇编程序需要  
       把大常数拆开，然后重新组合到寄存器里。比如加载一个32位立即数需要 lui（装入高位立即数）和addi两条  
       指令。像MIPS程序拆散和重装大常数由汇编程序来完成，汇编程序必需一个临时寄存器来重组大常数，这  
       也是为汇编 保留$at的原因之一。  
$2..$3:($v0-$v1)用于子程序的非浮点结果或返回值，对于子程序如何传递参数及如何返回，MIPS范围有一套约  
       定，堆栈中少数几个位置处的内容装入CPU寄存器，其相应内存位置保留未做定义，当这两个寄存器不够存  
       放返回值时，编译器通过内存来完成。  
$4..$7:($a0-$a3)用来传递前四个参数给子程序，不够的用堆栈。a0-a3和v0-v1以及ra一起来支持子程序／过程  
       调用，分别用以传递参数，返回结果和存放返回地址。当需要使用更多的寄存器时，就需要堆栈（stack)  
       了,MIPS编译器总是为参数在堆栈中留有空间以防有参数需要存储。  
$8..$15:($t0-$t7)临时寄存器，子程序可以使用它们而不用保留。  
$16..$23:($s0-$s7)保存寄存器，在过程调用过程中需要保留（被调用者保存和恢复，还包括$fp和$ra），MIPS  
       提供了临时寄存器和保存寄存器，这样就减少了寄存器溢出（spilling,即将不常用的变量放到存储器的过程),  
       编译器在编译一个叶（leaf)过程（不调用其它过程的过程）的时候，总是在临时寄存器分配完了才使用需要  
       保存的寄存器。  
$24..$25:($t8-$t9)同($t0-$t7)  
$26..$27:($k0,$k1)为操作系统／异常处理保留，至少要预留一个。 异常（或中断）是一种不需要在程序中显示  
       调用的过程。MIPS有个叫异常程序计数器（exception program counter,EPC)的寄存器，属于CP0寄存器，  
       用于保存造成异常的那条指令的地址。查看控制寄存器的唯一方法是把它复制到通用寄存器里，指令mfc0  
       (move from system control)可以将EPC中的地址复制到某个通用寄存器中，通过跳转语句（jr)，程序可以返  
       回到造成异常的那条指令处继续执行。MIPS程序员都必须保留两个寄存器$k0和$k1，供操作系统使用。  
       发生异常时，这两个寄存器的值不会被恢复，编译器也不使用k0和k1,异常处理函数可以将返回地址放到这  
       两个中的任何一个，然后使用jr跳转到造成异常的指令处继续执行。  
$28:($gp)为了简化静态数据的访问，MIPS软件保留了一个寄存器：全局指针gp(global pointer,$gp)，全局指针  
       只想静态数据区中的运行时决定的地址，在存取位于gp值上下32KB范围内的数据时，只需要一条以gp为基  
       指针的指令即可。在编译时，数据须在以gp为基指针的64KB范围内。  
$29:($sp)MIPS硬件并不直接支持堆栈，你可以把它用于别的目的，但为了使用别人的程序或让别人使用你的程  
       序， 还是要遵守这个约定的，但这和硬件没有关系。  
$30:($fp)GNU MIPS C编译器使用了帧指针(frame pointer),而SGI的C编译器没有使用，而把这个寄存器当作保  
       存寄存器使用（$s8),这节省了调用和返回开销，但增加了代码生成的复杂性。  
$31:($ra)存放返回地址，MIPS有个jal(jump-and-link,跳转并 链接)指令，在跳转到某个地址时，把下一条指令的  
       地址放到$ra中。用于支持子程序，例如调用程序把参数放到$a0~$a3,然后jal X跳到X过程，被调过程完成后  
       把结果放到$v0,$v1,然后使用jr $ra返回。  

##load&store
对内存单元的操作，使用的是load和store，对应的指令为ld和sw。注意，ld和sw只用唯一一种寻址模式，那就是base+offset的方式。基址base为寄存器，offset在ld和sw的机器码中是16位，转化为有符号数，就是正负32K。

##stack pointer
堆栈指针寄存器(sp)，MIPS使用的是直接的指令(例如addiu) 来升降堆栈，请注意区别在X86中使用指令POP和PUSH来升降堆栈的做法。在X86平台下，使用的是esp寄存器当做堆栈指针。

##global pointer
全局指针寄存器(gp)是MIPS的通用寄存器$28。这个寄存器的用途主要有两种：
    1. 在PIC中，gp用来指向GOT(Global Offset Table)。注意，这里的PIC是指的Linux中共享库中的PIC，而在vxWorks的BSP中的PIC只是简单的代码和地址无关，并不涉及到共享库，所以BSP中的gp的用法并不属于此类。
    2. 在嵌入式开发中，gp用来指向链接时决定的静态数据的地址。这样，对在gp所指地址正负各32K范围内数据的load和store（其实就是ld和sw指令），就可使用gp作为基址寄存器。有关数据的load和store，请看这里。 在romInit()函数向C函数romStart()函数跳转，usrStart()函数最开始两处都有gp的初始化。代码如下所示。
  
la gp, _gp   # set global ptr from compiler  
那么，_gp是什么呢？通过了解编译链接的过程，查看bootrom的符号表，可以看到,_gp就是链接器在链接时确定的一个静态数据的存放地址。在我们的代码中，大概是0x801656a0。  
$s8/frame pointer  
第九个通用寄存器$8，又叫做帧指针（frame pointer,fp）。在X86中，使用的是ebp寄存器当做帧指针。有关fp/sp，ebp/esp的相关内容，请参考C语言-Stack的相关内容。涉及堆栈帧（stack frame），活动记录（active record），调用惯例（call convention）等相关概念。  
分支延迟槽&加载延迟槽  
在早期的MIPS CPU上，对于从内存加载数据的操作，CPU没有提供互锁功能，这导致加载延迟槽对于程序员是可见的，也就是说，汇编程序员必须仔细处理加载延迟槽，否则得到的结果就可能是错误的。  
所谓互锁（interlock），是指CPU硬件提供的这样一种功能：如果指令的某个操作数尚未就绪，则推迟指令的执行，直到操作数就绪为止。在提供了互锁功能的CPU上，加载延迟槽对于程序员就是不可见的了，也就是说，即便在加载延迟槽中使用了加载指令操作的寄存器，得到的结果也是正确的（不过，这样做会牺牲一点性能）。早期的MIPS CPU没有提供互锁功能，但后来的MIPS CPU中都是加入了互锁功能的。那么，所谓早期MIPS CPU，到底是指哪些MIPS CPU呢，一般来讲，这是指MIPS I系列，MIPS I系列的典型代表就是MIPS R3000，这也正是我司路由器（大概也包括switch）上使用的大多数MIPS CPU所采用的处理器核。  
作为MIPS I系列的代表，MIPS R3000与后续的MIPS CPU在体系结构上存在着诸多差异，对加载延迟槽的不同处理只是这诸多差异中的其中一个，在移植、调试软件时，需要多注意这些差异之处。  
  
  
   
  
  
   
