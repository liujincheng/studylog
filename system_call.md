#系统调用
目的：
学习系统调用，了解从用户态切换到内核态的流程，跟踪用户态代码执行流程，学习常用工具分析如何做性能优化

##系统调用的实现原理
以Android native代码为例，分析系统调用的流程。用户调用系统函数，它要经历哪些流程？首先，是到lib库，由之转化为系统调用。比如fread会最终被转化为read函数。然后，保存当前进程上下文，使用汇编指令进入异常。第三步，kernel层面处理异常，并调到系统调用函数中执行实际的代码。第四步，系统调用执行完成后，使用汇编指令返回到用户进程。最后，用户进程从工具链函数中返回。本文是对系统调用整个流程的梳理。  

###system call entry point in kernel
如何快速找一个系统调用的函数原型？  
search "SYSCALL_DEFINE" globally, and then grep the system call name.


##编译阶段
每种体系结构都有自己的编译工具链，编译时，将应用程序和标准库链接在一起成为可执行文件。编译过程中，需要将可标准的posix C接口转化为该体系结构下的系统调用接口。比如申请内存，使用malloc接口，经过工具链转化，变成brk()接口。工具链相当于为POSIX C接口提供了一层适配层，使得可以访问不同体系结构的系统调用接口。

##执行阶段
用户程序首先调用工具链库的接口，比如malloc一个10个字节的内存，但是内核分配内存通常是按页来分配，所以库并不会直接将应用的C接口转化为系统调用，而是会做一些转换。库会首先检查是否有用户态的缓存页，如果有，则首先尝试从缓存中申请，如果没有内存，则调用brk()系统调用去内核申请。如上所述，工具链库在此充当一层胶合层，将应用和内核粘在一起。

系统调用的实现，取决于系统架构。就X86而言，提供一个int $0x80软件中断的汇编语言指令。int，表示中断。0x80，是中断号，内核根据中断号，查找到它对应的回调函数，来处理该中断。在回调函数中，首先需要保存当前进程的上下文，并将系统调用的参数，如eax、ebc等，存放在寄存器中。此处应该还需要设置cpu工作到内核态，以保证当前处理例程能够有足够高的优先级。

进入内核态之后，需要根据系统调用的编号，查找相应的处理函数，这部分代码也是特定于体系结构的。比如mips的系统调用编号的表格，就是定义在scall32-o32.S中。

内核态处理系统调用时，需要获取从用户态传入的参数。如果参数仅仅是一个标量，那么通过形参在切换到内核态时将数据保存到寄存器中。但更多情况，从用户态传入内核态的数据量较大，不适合通过参数来传递。此时可以使用copy_from_user和copy_to_user接口，操作当前进程的用户态的地址空间。注意到，及时是在内核，也不能直接访问用户态地址空间。究其原因，一方面，内核设计者认为用户态的地址是不可靠的，如果直接访问，那么有可能导致内核异常。另一方面，由于进程地址空间独立，所以同一个地址数值，在不同的进程上下文对应不同的物理内存，因此在访问用户态地址时需要考虑到当前进程的内存映射位置，也即copy_from/to_user在做的事情。

在用户态执行完毕后，需要返回用户态。执行的结果，有success，则一般返回值为0。有fail，一般返回一个负数，表示失败的原因。失败编号，在asm-mips/errno.h中定义。一般的，错误的返回值在-511~0之间。可以认为，超过这个范围的负数，并不是一个错误码，而是一个正常的返回值，只是这个返回值太大，已经超出了long型常量所能够表示的最大数值。

从内核返回时，也需要还原进程的上下文，首先还是到工具链库来处理，然后再返回到用户程序。
1. 上下文如何保存于恢复
2. 如何设置CPU到特权模式下，
3. 内核与用户态的地址空间是如何隔离的。


##应用性能优化：
###ptrace的实现方式
strace统计用到多少个系统调用，频率，消耗的时间等。
还可以分析每个系统调用
1. 首先通过PTRACE_ATTACH，设置进程的ptrace标志位PT_PTRACED，建立跟踪者进程和目标进程之间的父子关系，目标进程的真实父进程保存在real_parent中。
    设置PTRACE_SYSCALL，用于控制目标进程在合适的时机触发信号。这里触发的时机是有系统调用产生式，就触发信号。实质是设置进程的TIF_SYSCALL_TRACE标志位。
2. 然后再跟踪者进程中监听子进程的SIGCHLD信号。



