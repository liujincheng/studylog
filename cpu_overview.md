##指令集的分类
指令集是一块cpu对外的接口，提供哪些指令，每个指令的含义。一般指令集文档都在千页以上，包含了大量的微妙细节。通常在操作系统中，都只能采用汇编代码直接操作。

微内核已指令集的内部实现。相同的指令集，不同的厂家的实现方法可能完全不一样。比如Intel和AMD都实用X86指令集，但是各自的微内核不一样。这也是为什么Intel的cpu比AMD的要好用的原因。

指令集，有RISC和CISC之分。一般，在上世纪90年代，还有很多的CISC，这之后新产生的指令集，大都是RISC。

已Intel的X86指令集为例，指令集本身是CISC的，但是为了提高性能，在指令集和微内核之间，增加一个适配层，将外部的复杂指令转化为内部的简单指令。这样，即兼顾了市场，又保证了效率。

RISC领域，比较有名的两个指令集，是ARM和MIPS。其中ARM重点在手持设备上，而MIPS则主要在服务器市场上。前者注重低功耗低成本，后者注重高性能。得益于近年来手持设备的大规模爆发，ARM的占有率反超。

以MIPS的J指令为例，一个机器码，32个bit，其中固定6个bit用于指令，26个bit，用于跳转地址。这样，每个指令的长度是固定不变的。而在Intel的X86指令集中，有的指令只有一个lword，但是有的指令，却多达几个word。X86指令集长度不等，可以保证短的指令快速执行，但是带来 很多麻烦。比如如果指令长度相同，那么一次指令cache line取的指令个数是固定的。指令集长度相同，那么每个指令的执行流程也是大致相同，这样方便流水线并行执行。

##流水线
流水线的级数，与cpu的应用场景有关系。比如TI的DSP芯片，每个指令就被分层了很多级。下图为经典的MIPS的5级流水线。
IF，取值  
ID，译码，  
EX，执行  
MEM，内存访问，读或者写。  
WB，数据回写到通用寄存器。  

并不是每个指令都需要经过这5个阶段，比如运算操作，不访问内存，MEM阶段就为空。


##流水线上的冒险
主要原因，指令并不是毫无关联的，存在依赖关系。包括寄存器相关，控制相关。
* 结构冒险：指令和数据都存在存储器中，某一个节拍，不同的指令都需要操作存储器，就会发生冲突。将data和instruction的cache分离，可以解决该问题。
* 数据冒险：比如A指令处于WB阶段，尚未将数据回写到通用寄存器，而B指令已经在EX阶段需要读取通用寄存器了。这样就会产生错误。在A和B指令之间插入一个nop，可以解决问题。
                 一种提升性能的方式，MEM/EX指令都会操作通用寄存器，那么在A指令直接将数据传给B指令的EX操作。称之为CPU直通。
* 控制冒险：代码中广泛存在的跳转，for、if、while、switch导致cache失效，工作白做。
                 要解决该问题，需要引入分支预测技术。
编译器也可以优化代码，去除指令之间的相关性。包括去数据相关，去指令相关，去伪相关，寄存器重命名。

##分支预测
目标，通过算法预测下一条指令是什么，提前放入cache中。
* 1位预测：上一次执行了的执行，下一次还可能执行。
* 2位预测：执行了两次的指令，下一次再此执行的可能性很大。使用一个2bit的计数器来预测。
* 分支预测：以算法为基础，针对while，if等不同的跳转类型，做不同的策略。
                  向上的跳转被组织为循环，向下的跳转被组织为判断。向下预测为不跳转，向上预测为跳转。

##乱序执行
问题：指令的耗时长短不一样，比如读写内存。如果在执行耗时指令的时候，可以同步执行其他的指令，那么效率将会提高。

这就是乱序执行，不按照原有的顺序来执行。编译器可以优化。

为避免编译器优化，也可以在代码中加入barriar(）之类的陷阱，告诉编译器不要优化，保证执行的顺序。

##并行

#计算机组成原理
##计算机概要技术
1. CPU性能公式  
	CPU时间 = 指令数 * CPI * 时钟周期时间  
	CPU时间：一个程序执行完毕所需要的时间。包括用户时间和系统时间两部分。  
	指令数：指一个程序执行完所需要的指令的数目。这里的指令数，并不是指反汇编程序得到的指令数，而是指运行期间cpu执行的指令个数。可用仿真器测算。  
	CPI：指令执行所需要的时钟周期个数，为所有指令的时钟周期个数的平均值。比如乘法指令和加法指令所需要的时间不一样。示例：a%8和a&0x7，功能相同，但除法指令和位操作指令的时钟周期个数不一样。  
	时钟周期时间：即我们通常所说的时钟频率。比如2GHz的主CPU，时钟周期为1/2G = 500ps。  
	对于应用程序设计者来说，优化cpu性能，需要考虑如何减少指令数，可否使用更高效的指令。  
	对于cpu设计者来说，优化cpu性能，需要考虑在降低CPI和提高主频之间取得平衡。  

2. cpu功耗公式  
	动态功耗 = 负载电容 x 电压^2 x 开关频率，再考虑电流泄漏  
	静态功耗：泄漏电流导致的功耗。比如2008年时典型的电流蟹柳占40%的功耗。  
	开关频率是时钟频率的函数，负载电容是连接到输出的晶体管的数量和工艺的函数（比如20纳米和10纳米技术），电压指芯片的工作电压。  
	通过这个公式，可以理解为什么cpu的主频大幅增加，但是功耗却是减少的。因为负载电容在减少，且电压按照开平方的比率减少，从而主频增加对功耗带来的影响。  
	但封装工艺改进带来负载电容的较少存在极限，电压的减少也存在极限，因此芯片的功能逐步增加，导致cpu主频近年来提升有限。 
	为解决功耗问题，芯片的设计者可以关闭一些不必要的器件，或者加速冷却（比如将一些常用的器件分散放置？）等。  
	在低功耗蓝牙芯片和低功耗传感器中，这两种技术都有用来优化功耗问题：  
	1） 不用的模块处于休眠状态，不工作。  
	2） 优化蓝牙协议栈，避免让cpu长时间工作。  
	3） 减少内存使用。  

##第二章 指令：计算机的语言
1. 指令集的设计准则  
	设计准则1：简单源于规整。 固定操作数为三个（RISC）。  
	设计准则2：只有32个寄存器。越少越快，大量的寄存器可能会使得时钟周期变长，因为需要更元的电信号传输距离。  
	设计准则3：加速常用操作。  
	设计准则4：优秀的设计需要适宜的折中方案。并不是所有的指令的操作数都能固定为三个。  

2. MIPS汇编指令中的操作数
	汇编指令由操作数组成，操作数可以是寄存器，或者是立即数。内存地址可以为立即数，也可以通过寄存器指定。
	1) 寄存器，以及寄存器加偏移。如$s3, 8($s3)
	2) 常数或立即数，如addi $s3, $s3, 4（为$s3寄存器中的值加4）； jal 2500(跳转到2500*4的地址)
	立即数包括有符号数和无符号数。有符号数用补码表示。高位补1。x + ~x = -1，可以快速得到x的十进制值。

3. 机器指令的格式

算数指令：加减乘除 add sub addi
                 寄存器之间的赋值指令move，其实是add $a0,$a1,$zero的伪指令。

逻辑指令：and or nor addi ori sll srl 

传输指令：和存储器打交道的指令。lw sw  lh lhu sh lb lbu sb  lui(取立即字的高位)

同步指令：同步指令是传输指令的一类，用于原子地在cpu和主存之间以原子的方式交换数据。 l l(取链接字？)  sc(存条件字)
                  ll

跳转指令： j(函数内跳转) jr(跳转到寄存器的地址) jal(跳转连接指令，函数调用)   
		  用于实现函数调用和函数返回，需要注意将寄存器的值存到栈中，或从栈中恢复。  
		  实现4 * 2^26地址范围的寻址，即最大可寻址256M内存，也即需要注意不要让程序可执行文件超过256M。  
		  跳转指令中的立即数，表示指令的个数，需要乘4。通过这种方式，扩大指令跳转的返回。  

决策指令：beq(branch equal) bne slt(set less than小于时置位) sltu slti sltiu
		  相对于$pc正负4 * 2^15的地址范围的寻址
		  使用决策指令，可以构造出if-else-if, switch-case-break, for-loop, while-loop等函数。

MIPS没有堆栈操作的指令，堆栈操作，通过修改$sp寄存器完成。


##第四章  处理器
mips指令集得核心子集: ALU实现
* 存储器指令，加载与存储字
* 算数逻辑指令，加减乘除，与，或，小于则设置
* 分支指令，相等则分支，跳转

##第6章 存储器和其他IO主题
I/O重点在可信度与成本，还考虑可扩展性和多样性。处理器和内存重点在性能与成本

I/O评测，吞吐量与延时
总线，switch，互联各种外设，内存是高速总线，I/O外设低速总线。表面上，并行总线速率要高，但是时钟对齐，信号反射等问题，实际无法达到很高的速率。

总线，包括sgmii，gmii总线。比如前端总线速率达到10.5GBps。总线的难度在于控制与时钟对齐。

I/O的三个主题
1. 如何发送控制I/O指令到设备，如何将数据到内存的输入和输出，操作系统扮演什么角色（调度并发事件从而共享总线，通过中断主动通知系统，）
2. 控制I/O设备的方法
3. 将I/O寄存器映射到虚拟地址空间，处理器发送cpu指令，I/O控制器分发指令

I/O指令

三种I/O数据传输方法
1. 轮巡
2. 中断
3. dma





 


 


